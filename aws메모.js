// AWS

// ----------------------------------- 1일차 ----------------------------------- //
/** 배포(Deployment)란?
 * 배포(Deployment)란 다른 사용자들이 인터넷을 통해서 사용할 수 있게 만드는 걸 의미한다.
 * 쉽게 얘기해서 우리가 만든 웹 페이지나 서버를 다른 사람들이 사용하려면 인터넷 상에 배포가 돼있어야 한다.
 */

/** AWS란?
 * 원격으로 컴퓨터를 빌려서 사용할 수 있게 해주는 서비스(클라우드 서비스)
 */

/** S3란?
 * 파일을 저장하고 다운로드 할 수 있는 서비스
 */

/** 프론트 배포할 때 S3를 사용하는 걸까?
 * S3는 파일 저장 및 다운로드 이외에도 웹 호스팅 기능도 가지고 있다.
 * 웹 페이지를 운영하고 있는 서버로부터 HTML, CSS, JS 이미지 파일 등을 다운받아와서 브라우저에 끼워넣어서 실행시키는 방식이다.
 * 파일을 다운 받아와야 하기 때문에 S3를 활용해서 사용한다.
 */

/** 현업에서 프론트 엔드 서비스를 배포할 때 S3를 많이 활용할까?
 * yes!
 */

/** 버킷
 * 깃허브에서 여러 레포지토리를 만들 수 있는것 처럼 S3에서도 여러개의 저장소를 만들 수 있다.
 * 버킷이란 하나의 저장소를 의미한다.
 */

/** S3에서의 객체란
 * S3 버킷의 업로드된 파일을 의미한다.
 * 버킷에 저장되는 파일을 객체라 한다.
 */

/** 버킷생성 - 이 버킷의 퍼블릭 액세스 차단 설정
 * S3에 접근할 수 있게 할것인지 아닌지를 의미
 * S3에 저장되어 있는 파일을 다운받을 수 있게끔 접근을 열어줄 것인지
 */

/** 정책이란
 * 권한을 정의하는 json문서.
 */

/** 정책 설정
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Sid": "Statement1", ----- 정책에 대한 고유 아이디값을 설정(기본값으로..)
      "Effect": "Allow", ------ 허용을 하겠다.
      "Principal": "*", ------ 주체를 뜻함(모든 사용자에게서 기능을 허용해야 하기 때문에 "*"로 설정)
      "Action": "s3:GetObject", ----- S3에서 파일을 다운받는 기능
      "Resource": "arn:aws:s3:::tosio-instagram-web/*"
    }
  ]
}

뜻 - 모든 사용자에게 S3의 tosio-instagram-web 버킷 내의 객체(파일)만 다운로드할 수 있는 기능을 허용하겠다.
 */

// ----------------------------------- 2일차 ----------------------------------- //
/** React - CRA
 * S3에 리액트 파일을 올리려면 npm run build 실행 시켜야한다.
 * [build]폴더가 생성되면 [build]폴더 내에 있는 파일을 버킷에 업로드
 * ***** [build]폴더를 업로드 하는것이 아니다!
 */

/** React - VITE
 * S3에 리액트 파일을 올리려면 npm run build 실행 시켜야한다.
 * [dist]폴더가 생성되면 [dist]폴더 내에 있는 파일을 버킷에 업로드
 * ***** [dist]폴더를 업로드 하는것이 아니다!
 */

/** Next.js
 * next.config.mjs 파일에서 선언된 nextConfig에 output: 'export' 추가 작성 후 npm run build 실행
const nextConfig = {
  output: 'export'
};
 * [out]폴더가 생성되면 [out]폴더 내에 있는 파일을 버킷에 업로드
 * ***** [out]폴더를 업로드 하는것이 아니다!
 */

/** CDN
 * 웹 콘텐츠를 사용자에게 더 빠르고 효율적으로 전달하기 위해 설계된 시스템
 * CDN은 웹 사이트나 애플리케이션의 콘텐츠를 여러 서버에 분산시켜 놓고,
 * 사용자가 그 콘텐츠에 접근할 때 가장 가까운 서버에서 제공함으로써
 * 로딩 속도를 개선하고 서버 부하를 줄이는 역할
 */

/** CloudFront란?
 * 컨텐츠(파일, 동영상 등)를 빠르게 전송하게 해주는 서비스
 */

/** CloudFront의 작동 과정
 * 1. 배포 생성
 * - CloudFront 배포를 생성
 * - 배포는 콘텐츠를 제공할 설정을 포함하며 오리진이라고 하는 원본 서버를 지정
 * - 오리진은 S3 버킷, HTTP서버, Elastic Load Balancer 등일 수 있다.
 *
 * 2. 도메인 설정
 * - CloudFront는 배포를 생성할 때 자동으로 도메인 이름을 할당
 * - 이를 통해 사용자들은 이 도메인 이름을 통해 콘텐츠에 접근
 * - 커스텀 도메인 이름을 설정할 수도 있다.
 *
 * 3. 캐싱
 * - 사용자가 CloudFront 도메인을 통해 요청을 하면, CloudFront 엣지 서버(edge location)라고 불리는 글로벌 캐시 서버 네트워크에서 요청을 처리
 * - 이 서버들은 사용자와 가장 가까운 위치에 배치되어 있다.
 * - 엣지 서버는 오리진 서버에서 콘텐츠를 가져와서 캐시해 두고, 이후 동일한 콘텐츠에 대한 요청이 오면 캐시된 콘텐츠를 제공하여 응답 속도를 빠르게 한다.
 *
 * 4. 요청 처리
 * - 사용자가 CloudFront 도메인을 통해 콘텐츠를 요청하면, 요청이 가장 가까운 엣지 서버로 라우팅 된다.
 * - 엣지 서버는 해당 콘텐츠가 캐시되어 있는지 확인하고, 캐시된 콘텐츠가 있으면 이를 사용자에게 제공하며, 없으면 오리진 서버로 요청을 전달
 *
 * 5. 오리진 서버와의 상호작용
 * - 엣지 서버에서 요청한 콘텐츠가 캐시에 없을 경우, 오리진 서버에 요청을 전달
 * - 오리진 서버는 요청된 콘텐츠를 엣지 서버에 반환하며, 엣지 서버는 이 콘텐츠를 캐시하고 사용자에게 전달
 *
 * 6. 응답 반환
 * - 사용자는 엣지 서버를 통해 응답을 받는다.
 * - 이후 동일한 콘텐츠에 대한 추가 요청이 있을 때, 엣지 서버에서 캐시된 콘텐츠를 빠르게 제공할 수 있다.
 *
 * 7. 캐시 갱신 및 무효화
 * - CloudFront는 캐시된 콘텐츠의 유효 기간을 설정할 수 있으며, 시간이 지나면 자동으로 캐시를 갱신
 * - 관리자는 필요에 따라 특정 콘텐츠를 강제로 무효화하거나 갱신할 수도 있다.
 *
 * CloudFront는 이 과정을 통해 웹 콘텐츠의 배포를 효율적으로 처리하고, 전 세계 사용자에게 빠르고 안정적인 콘텐츠 제공을 목표로 한다.
 */

/** CloudFront를 사용하였을 때의 이점
 * 웹페이지에 접속했을때 렉이 걸리지 않게끔 속도를 올려주는 역할
 * HTTPS를 적용시키게끔 하는 기능을 제공
 */

/** CloudFront를 사용한 아키텍쳐 구성
 * user → Amazon CloudFront(가장 가까운 임시 파일 저장소) → Amazon S3
 *
 * 1. 사용자
 * - 웹 브라우저 또는 모바일 애플리케이션: CloudFront를 통해 웹 콘텐츠를 요청하는 최종 사용자
 *
 * 2. CloudFront 배포
 * - 디스트리뷰션: CloudFront에서 콘텐츠를 제공하기 위해 설정한 배포, 사용자의 요청을 가장 가까운 엣지 서버로 라우팅
 *
 * 3. 엣지 서버
 * - CloudFront 엣지 로케이션: 전 세계에 분산된 서버들로, 사용자와 가장 가까운 서버에서 콘텐츠를 캐시하고 제공하여 응답 시간을 줄인다.
 *
 * 4. 오리진 서버
 * - 원본 서버: CloudFront가 콘텐츠를 가져오는 출처, 오리진 서버는 웹 애플리케이션 서버, Amazon S3 버킷, AWS Elastic Load Balancer, 또는 다른 HTTP 서버일 수 있다.
 *
 * 5. DNS
 * - Route 53: AWS의 DNS 서비스로, 사용자 요청을 CloudFront 배포의 도메인 이름으로 라우팅, 커스텀 도메인 이름을 설정할 수 있다.
 */

/** HTTP
 * HTTP는 웹에서 데이터를 주고받기 위한 기본 프로토콜
 * 웹 페이지, 이미지, 비디오 등 다양한 웹 콘텐츠를 클라이언트(사용자의 웹 브라우저)와 서버 간에 전송
 */

/** HTTPS
 * HTTPS는 HTTP의 보안 버전
 * HTTP에 SSL/TLS(보안 소켓 계층/전송 계층 보안)를 추가하여 데이터 전송 시 암호화를 제공
 */

/** HTTP/HTTPS 요약
 * HTTP: 데이터를 암호화하지 않고 평문으로 전송하며, 보안이 취약할 수 있음.
 * HTTPS: SSL/TLS를 통해 데이터를 암호화하고, 보안을 강화하여 안전한 데이터 전송을 제공함.
 */

/** HTTPS를 사용했을때의 이점
 * 1. 데이터의 암호화
 * - HTTPS는 데이터 전송 중 암호화를 통해 중간에서 데이터를 엿보거나 탈취하는 것을 방지
 * - 이를 통해 사용자의 로그인 정보, 개인 정보, 결제 정보 등을 안전하게 보호할 수 있
 *
 * 2. 데이터 무결성
 * - HTTPS는 데이터가 전송 중에 손상되거나 변경되지 않도록 보장
 * - 무결성 검사를 통해 데이터가 서버에서 클라이언트로 전달되는 동안 원본 그대로 유지되도록
 *
 * 3. 서버 인증
 * - SSL/TLS 인증서를 사용하여 웹사이트의 신원을 검증
 * - 사용자는 인증서의 유효성을 확인함으로써 사이트가 실제로 주장하는 대로 신뢰할 수 있는 기관에 의해 인증되었음을 보장받는다.
 * - 이를 통해 피싱 사이트나 가짜 웹사이트의 위험을 줄일 수 있다.
 *
 * 4. 사용자 신뢰 향상
 * - 웹 브라우저에서 자물쇠 아이콘과 "https://"로 시작하는 URL을 통해 사용자에게 사이트가 안전하다는 신호를 제공
 * - 이는 사용자의 신뢰를 높이고, 사이트의 신뢰성을 강화하는 데 기여
 *
 * 5. SEO 혜택
 * - 구글과 같은 검색 엔진은 HTTPS를 사용하는 웹사이트에 대해 더 높은 순위를 부여
 * - HTTPS는 사이트의 신뢰성과 보안을 반영하므로 SEO에 긍정적인 영향을 미친다.
 *
 * 6. 법적 및 규제 요구사항
 * - GDPR, CCPA 등 여러 데이터 보호 법규에서 HTTPS 사용을 권장하거나 요구할 수 있다.
 * - HTTPS를 사용하면 이러한 법적 요구사항을 충족하는 데 도움이 된다.
 *
 * 7. 데이터 보호를 위한 추가 기능
 * - HSTS (HTTP Strict Transport Security): HTTPS를 사용하면 HSTS를 통해 클라이언트가 HTTP 대신 HTTPS만 사용하도록 강제할 수 있다. 이는 사용자가 HTTPS로만 사이트에 접근하도록 하여 보안을 강화
 * - Content Security Policy (CSP): HTTPS를 통해 CSP를 구현하여 사이트에서 로드되는 콘텐츠를 제어하고 악성 콘텐츠의 삽입을 방지할 수 있다.
 *
 * 8. 피싱 방지
 * - HTTPS를 사용하면 사용자가 연결된 웹사이트가 신뢰할 수 있는 사이트인지 확인할 수 있으며, 이는 피싱 공격의 위험을 줄이는 데 도움이 된다.
 */

// ----------------------------------- 3일차 ----------------------------------- //
/** 도메인/DNS란?
  도메인이 없던 시절에는 특정 컴퓨터와 통신하기 위해서 IP 주소(ex. 12.134.122.11)를 사용했다.
  이 IP는 특정 컴퓨터를 가리키는 주소의 역할을 한다.
  하지만 IP 주소는 많은 숫자들로 이루어져 있어서 일일이 외우기가 너무 불편했다.
  컴퓨터가 처리하기 쉬운 값의 형태는 문자가 아니라 숫자이기 때문이다.

  이를 해결하기 위해 [문자를 IP주소로 변환해주는 하나의 시스템(서버)]을 만들게 됐다.
  이게 바로 DNS(Domain Name System)이다.
 */

/** Route 53이란?
 * 도메인을 발급하고 관리해주는 서비스
 * Route 53을 조금 더 전문적인 용어로 표현하자면 DNS서비스이다.
 */

/** IP의 개념
 * 네트워크 상에서의 특정 컴퓨터를 가리키는 주소
 */

/** Port의 개념
 * 한 컴퓨터 내에서 실행되고 있는 특정 프로그램의 주소
 *
 * 외부에서 특정 컴퓨터 내부에 있는 Spring Boot라는 서버에 통신을 하고 싶다고 가정했을때
 * 외부에서 IP 주소만 알아서는 실행되고 있는 여러 프로그램 중 어떤 프로그램과 통신을 해야 할 지 알 수가 없다.
 * 그래서 특정 서버와 통신을 할 때는 IP 주소와 서버가 실행되고 있는 [포트 번호]까지 알고 있어야 한다.
 */

/** 브라우저 창에 포트 번호를 입력하지 않는 이유
 * 특정 서버와 통신하기 위해서는 [IP 주소]와  [포트 번호]를 둘 다 알아야 된다고 했다.
 * 도메인 주소를 통해서 알 수 있는 건 [IP 주소] 뿐이다. 그럼 [포트 번호]를 입력해주지도 않았는데
 * 어떻게 정상적으로 통신을 한 걸까?
 *
 * 주소창에 도메인 주소를 입력해서 엔터를 누르면, [브라우저(크롬, 익스플로러)는 기본적으로 80번 포트로 통신을 보내게 설정되어 있다.]
 * 그래서 포트 번호를 입력해주지 않아도 통신이 잘 됐던 것이다.
 * 만약 80번 포트로 통신하고 싶지 않고, 3000번 포트로 통신하고 싶다면..(ex. naver.com:3000)
 */

/** 잘 알려진 포트(well-known port)란?
 * 포트에는 잘 알려진 포트라는 개념이 있다.
 * 포트 번호는 0~65,535번까지 사용할 수 있다.
 * 그 중에서 0~1023번까지의 포트 번호는 주요 통신을 위한 규약에 따라 이미 정해져 있다.
 * 이렇게 규약을 통해 역할이 정해져있는 포트 번호를 보고 잘 알려진 포트라고 부른다.
 *
 * 규약으로 정해져 있는 포트 번호 중 자주 사용되는 포트 번호에 대해서만 알아보자
 * - 22번(SSH, Secure Shell Protocol) : 원격 접속을 위한 포트 번호
 * -- EC2 인스턴스에 연결할 때 22번 포트를 사용한다.
 * - 80번(HTTP) : HTTP로 통신을 할 때 사용
 * - 443번(HTTPS) : HTTPS로 통신을 할 때 사용
 *
 * 정해놓은 규약을 꼭 지키지 않아도 된다.
 * 즉, 규약으로 정해져 있는 포트 번호와 다르게 사용해도 된다는 뜻이다.
 * 예를들어, 특정 서버와 HTTP 통신을 할 때 80번 포트를 쓰지 않고 3000번 포트나 8080번 포트를 써도 상관 없다.
 */

/** 무료도메인
 * 구글검색 - 내도메인한국 - https://xn--220b31d95hq8o.xn--3e0b707e/
 * 메인페이지 - 일반 도메인 검색 - 원하는 도메인 등록하기
 * 도메인 관리 - 도메인 수정 - 고급설정(DNS)에서
 * - IP연결(A) : IP연결 라인에 명시되어 있는 주소로 들어왔을때 어떤 IP주소를 반환할것인지 작성할 때(IP를 연결시킬때)
 * - 별칭(CNAME) : 다른 도메인 주소를 연결시킬때
 */

/** S3, CloudFront DNS를 사용한 아키텍쳐 구성과 흐름
 * 1. 콘텐츠 업로드
 * - 사용자는 Amazon S3에 정적 콘텐츠를 업로드
 *
 * 2. CloudFront 배포 설정
 * - CloudFront 배포를 생성하고, S3 버킷을 원본(Origin)으로 설정
 * - CloudFront는 전 세계에 위치한 엣지 로케이션에서 콘텐츠를 캐시
 * - CloudFront 배포에는 도메인 이름이 자동으로 할당되며, 이 도메인 이름을 통해 콘텐츠를 요청
 *
 * 3. 도메인 이름 설정
 * - 도메인 이름을 구입하거나 기존 도메인을 사용
 * - DNS 설정을 통해 도메인 이름을 CloudFront 배포에 매핑, 일반적으로 DNS 관리자는 CloudFront 배포에서 제공하는 CNAME(별칭) 레코드를 사용하여 도메인을 설정
 * - DNS 설정을 통해 도메인 이름이 CloudFront의 도메인 이름(CNAME)으로 포워딩되도록 구성
 *
 * 4. 사용자 요청 처리
 * - 사용자가 브라우저에 도메인 이름을 입력
 * - DNS가 도메인 이름을 CloudFront 배포의 IP 주소로 변환
 * - 브라우저는 CloudFront 엣지 로케이션에 요청
 * - CloudFront는 요청된 콘텐츠가 캐시된 경우, 캐시에서 콘텐츠를 제공하고, 그렇지 않으면 S3 버킷에서 콘텐츠를 가져온다.
 * - CloudFront는 요청된 콘텐츠를 사용자에게 전달하고, 필요한 경우 S3 버킷에서 최신 콘텐츠를 업데이트하여 캐싱
 */

/** 무료 도메인 서버의 한계점
 * 무료 서버이다 보니 가끔 불안정하다.
 * 접속이 안된다거나 사이트에 장애가 발생한다..
 */

// ----------------------------------- 4일차 ----------------------------------- //
/** CI/CD란?
 * Continuous Integration, Continuous Deployment라는 의미를 가지고 있다.
 * CI/CD는 테스트(test), 통합(Merge), 배포(Deploy)의 과정을 자동화하는 걸 의미한다.
 */

/** CI/CD를 배우는 이유
 * 서비스를 운영하다보면 새로운 기능을 추가하는 일이 많아진다.
 * 새로운 기능에 대한 코드를 작성한 뒤에 Commit을 찍는다.
 * 그런 뒤에 브랜치에 Merge를 하고 배포를 한다.
 * 배포를 할 때 직접 컴퓨터 서버(ex AWS EC2)에 접속해서 새로운 코드를 다운받아 실행시켜주어야 한다.
 *
 * 이 과정을 코드의 수정이 일어날 때마다 반복하기란 너무 귀찮은 일이다.
 * 그래서 이런 반복적인 과정을 자동화시키기 위해 CI/CD를 배우는 것이다.
 */

/** CI/CD 환경을 구축하는 이유
 * 1. 코드 품질 향상: 자동 테스트로 버그를 조기에 발견.
 * 2. 빠른 배포: 신속하게 기능을 출시할 수 있음.
 * 3. 협업 개선: 개발자 간 통합이 용이해짐.
 * 4. 리스크 감소: 작은 변경으로 문제 해결이 쉬움.
 * 5. 신속한 피드백: 사용자 피드백을 빠르게 반영.
 * 6. 자원 효율성: 자동화로 인적 자원 절약.
 * 7. 일관성 유지: 배포 과정의 표준화로 환경 간 일관성 확보.
 */

/** CI/CD의 일반적인 과정
 * DEVELOP -> COMMIT -> BUILD -> TEST -> DEPLOY
 *
 * 1. 코드 작성: 개발자가 코드를 작성
 * 2. 커밋: 코드를 버전 관리 시스템에 커밋
 * 3. 빌드 트리거: 커밋 시 CI 서버가 자동으로 빌드 및 테스트를 시작
 * 4. 자동 빌드: 코드가 빌드
 * 5. 자동 테스트: 빌드된 코드에 대해 자동화된 테스트가 실행
 * 6. 배포 준비: 테스트가 성공하면 스테이징 또는 프로덕션 환경에 배포
 * 7. 자동 배포: 코드가 자동으로 배포
 */

/** CI/CD를 구축할 때 사용할 툴
 * - Github Actions - 현업에서 많이사용/무료로 사용/빌드용 서버가 필요없음
 * - Jenkins
 * - Circle CI
 * - Travis CI
 * - 등등...
 */

/** Github Actions
 * Github Actions를 로직을 실행시킬 수 있는 일종의 컴퓨터라고 생각하면 된다.
 * CI/CD 과정에서 Github Actions는 "빌드, 테스트, 배포"에 대한 로직을 실행시키는 역할을 하게 된다.
 */

/** Github Actions를 사용한 CI/CD의 아키텍처와 흐름
 * 1. 코드 작성 후 Commit
 * 2. Github에 Push
 * 3. Push를 감지해서 Github Actions에 작성한 로직이 실행
 *  - a. 빌드(build)
 *  - b. 테스트(test)
 *  - c. 서버로 배포(Deploy)
 * 4. 서버에서 배포된 최신 코드로 서버를 재실행
 */
